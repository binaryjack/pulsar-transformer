# Batch Updates Implementation Plan

## Short Description

Implement transformation support for `batch(() => {})` batched update patterns for performance optimization.

## Mandatory AI Task Before Start

- Read carefully and respect the following rules
- Link to ai-collaboration-rules: `C:\Users\Piana Tadeo\source\repos\visual-schema-builder\packages\pulsar-transformer\docs\ai-collaboration-rules.json`

## What to Do

1. Parse `batch(() => {})` syntax
2. Transform to batched update system
3. Handle update batching and scheduling
4. Implement batch boundary detection
5. Support nested batching scenarios
6. Optimize batch performance and timing

## Framework Analysis

**How Major Frameworks Handle Batching:**

**React:**
- Automatic batching (React 18+) for all updates
- `startTransition(() => {})` for marking non-urgent updates
- Batches updates within event handlers, hooks, and async functions
- Uses internal scheduler for prioritization

**Solid.js:**
- `batch(() => { signal1(1); signal2(2); })` explicit batching
- Groups multiple signal updates into single reactive cycle
- Prevents intermediate renders
- Can nest `batch()` calls - outer batch wins

**Vue:**
- Automatic batching via `nextTick()` queue
- All synchronous updates batched together
- `nextTick()` callback runs after batch completes
- No manual batching API needed

**Svelte:**
- Automatic batching by compiler
- Updates within single function batched
- `tick()` returns promise that resolves after batch

**Key Insights for PSR Implementation:**
1. **Solid's Manual Control:** `batch()` gives explicit control when needed
2. **Automatic by Default:** Most updates should batch automatically (like Vue/React 18)
3. **Prevents Redundant Updates:** Multiple signal changes → single effect run
4. **Nesting:** Inner batch extends outer batch (no early flush)
5. **Performance Critical:** Essential for handling multiple state updates

**Implementation Strategy:**
- Transform `batch(() => {})` to batching scope
- Queue signal updates during batch
- Flush all updates at batch end
- Support nested batching - track batch depth
- Automatic batching for common patterns (event handlers)

## Debug Tracking Requirements

**CRITICAL:** While implementing this feature, ensure the debug tracker system has comprehensive tracing:

### 1. Tracer Integration

```typescript
import { traced } from '../debug/tracer/index.js';

export const transformBatch = traced('transformer', (node) => {
  /* implementation */
}, {
  extractPertinent: (args, result) => ({
    updateCount: result.updateCount,
    batchSize: result.batchSize
  })
});
```

### 2. Logger Integration

```typescript
const logger = createLogger({ enabled: context.debug, level: 'debug', channels: ['transform'] });
logger.debug('transform', 'Transforming batch(() => {})');
const result = transformBatchUpdate(node);
logger.info('transform', `✅ Batch transformed (${result.updateCount} updates)`);
```

### 3. Transformation Step Tracking

```typescript
trackTransformStep(context, {
  phase: 'transform',
  input: { nodeType: 'CallExpression', name: 'batch', location: node.location },
  output: { nodeType: 'BatchScope', code: getGeneratedCode(result) },
  metadata: { updateCount: result.updateCount, nested: node.isNested }
});
```

### 4. Diagnostic Collection

```typescript
if (result.updateCount < 2) {
  context.diagnostics.push({
    phase: 'transform',
    type: 'info',
    message: 'Batching single update has no performance benefit',
    code: 'PSR-T-INFO-007',
    location: { file: context.sourceFile, line: node.location.line, column: node.location.column }
  });
}
```

## Test Requirements

Ask the agent to create test files:

- Integration tests for batch update transformations
- Unit tests for batching algorithms
- E2E tests for performance optimization

## Final Step

Invoke supervisor for review of implementation completion.
