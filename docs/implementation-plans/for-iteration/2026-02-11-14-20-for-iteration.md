# For Iteration Implementation Plan

## Short Description

Implement transformation support for `<For each={array} key={fn}>` iteration components for reactive list rendering.

## Mandatory AI Task Before Start

- Read carefully and respect the following rules
- Link to ai-collaboration-rules: `C:\Users\Piana Tadeo\source\repos\visual-schema-builder\packages\pulsar-transformer\docs\ai-collaboration-rules.json`

## What to Do

1. Parse `<For each={array} key={fn}>` syntax
2. Transform to efficient reactive list rendering
3. Implement keyed reconciliation algorithm
4. Handle dynamic array updates
5. Optimize performance for large lists
6. Support nested For components

## Framework Analysis

**How Major Frameworks Handle List Rendering:**

**React:**
- `.map()` with `key` prop: `{items.map(item => <Item key={item.id} />)}`
- Virtual DOM diffing to minimize DOM updates
- Re-renders all items when array changes (unless optimized with `React.memo`)
- Keys must be stable and unique

**Solid.js (Gold Standard for PSR):**
- `<For each={items()}>{(item, index) => <Item value={item} />}</For>`
- Referential equality keying - only changed items re-render
- Tracks each item independently for fine-grained updates
- `index()` is a signal that updates when position changes
- Automatic disposal of removed items

**Vue:**
- `v-for` directive: `<li v-for="item in items" :key="item.id">`
- Reactive array tracking with getter/setter proxies
- In-place patch strategy by default
- Keys used for reordering optimization

**Svelte:**
- `{#each items as item (item.id)}` with keyed syntax
- Compiler generates optimized loop code
- Tracks by key expression in parentheses
- Efficient add/remove/reorder operations

**Key Insights for PSR Implementation:**
1. **Referential Keying:** Solid's approach only re-renders changed items (no need for `key` prop if items are stable references)
2. **Index as Signal:** Making `index()` reactive allows position-dependent updates
3. **Fine-Grained Updates:** Each item should be independently reactive
4. **Automatic Cleanup:** Dispose computations/effects when items are removed
5. **Performance:** Large lists should not trigger full re-renders

**Implementation Strategy:**
- Transform `<For each={array()}>` to mapped reactive items
- Use referential identity for tracking items (like Solid)
- Provide optional `key` function for custom keying
- Implement reconciliation algorithm for adds/removes/moves
- Track each item's index as a reactive signal

## Debug Tracking Requirements

**CRITICAL:** While implementing this feature, ensure the debug tracker system has comprehensive tracing:

### 1. Tracer Integration

```typescript
export const transformForComponent = traced(
  'transformer',
  function (node: ForComponent) {
    // Implementation
  },
  {
    extractPertinent: (args, result) => ({
      hasEach: !!args[0].each,
      hasKey: !!args[0].key,
      childCount: args[0].children.length,
      reconciliationType: result.reconciliationType,
    }),
  }
);

export function processForItems(items: ForItem[]) {
  return tracedLoop(
    'transformer',
    items,
    (item, i) => {
      // Process each iteration item
    },
    {
      extractPertinent: (item) => ({
        key: item.key,
        index: item.index,
      }),
    }
  );
}
```

### 2. Logger Integration

```typescript
logger.debug('transform', `Transforming For component with ${node.each?.length || 0} items`);
logger.time('for-component-transform');

const result = transformIterativeRendering(node);

logger.info('transform', 'âœ… For component transformed', {
  hasEach: !!node.each,
  hasKey: !!node.key,
  reconciliation: result.reconciliationType,
});
logger.timeEnd('for-component-transform');
```

### 3. Transformation Step Tracking

```typescript
trackTransformStep({
  phase: 'transform',
  input: { nodeType: 'ForComponent', code: getCode(node), location: node.location },
  output: { nodeType: 'MapExpression', code: getGeneratedCode(result) },
  metadata: {
    reactive: true,
    dependencies: [node.each.deps],
    generated: ['map_' + id, 'key_fn_' + id],
    reconciliation: result.reconciliationType,
  },
});
```

### 4. Diagnostic Collection

```typescript
if (!node.key) {
  context.diagnostics.push({
    phase: 'transform',
    type: 'warning',
    message: 'For component without key prop may have performance issues',
    code: 'PSR-T006',
    location: node.location,
    suggestions: ['Add key={item => item.id} prop for better reconciliation'],
  });
}
```

## Test Requirements

Ask the agent to create test files:

- Integration tests for For component transformation
- Unit tests for reconciliation algorithm
- E2E tests for performance with large datasets

## Final Step

Invoke supervisor for review of implementation completion.
